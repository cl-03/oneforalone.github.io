<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>第五章：Programs that program &mdash; Let Over Lambda 中文文档  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="第六章：回指（Anaphoric）宏" href="chapter06.html" />
    <link rel="prev" title="第四章：读取宏" href="chapter04.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> Let Over Lambda 中文文档
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="preface.html">译者序</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter01.html">第一章：概述</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter02.html">第二章：闭包</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter03.html">第三章：宏基础</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter04.html">第四章：读取宏</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">第五章：Programs that program</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#lisp-is-not-funcitonal">5.1 非函数式编程</a></li>
<li class="toctree-l2"><a class="reference internal" href="#topdown-programming">5.2 自上而下的编程</a></li>
<li class="toctree-l2"><a class="reference internal" href="#implicit-contexts">5.3 隐式上下文</a></li>
<li class="toctree-l2"><a class="reference internal" href="#macrolet">5.4 使用 <strong>macrolet</strong> 遍历代码</a></li>
<li class="toctree-l2"><a class="reference internal" href="#recursive-expansions">5.5 递归展开</a></li>
<li class="toctree-l2"><a class="reference internal" href="#recursive-solutions">5.6 递归方案</a></li>
<li class="toctree-l2"><a class="reference internal" href="#dlambda">5.7 Dlambda</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="chapter06.html">第六章：回指（Anaphoric）宏</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter07.html">第七章：宏的效率</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter08.html">第八章：Lisp 和 Forth</a></li>
<li class="toctree-l1"><a class="reference internal" href="appendices.html">附录</a></li>
<li class="toctree-l1"><a class="reference internal" href="reference.html">参考文档</a></li>
<li class="toctree-l1"><a class="reference internal" href="specification.html">术语表</a></li>
<li class="toctree-l1"><a class="reference internal" href="original-code.html">源代码</a></li>
<li class="toctree-l1"><a class="reference internal" href="production-code.html">生产代码</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Let Over Lambda 中文文档</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>第五章：Programs that program</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/chapter05.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="programs-that-program">
<span id="chapter05"></span><h1>第五章：Programs that program<a class="headerlink" href="#programs-that-program" title="Permalink to this heading"></a></h1>
<section id="lisp-is-not-funcitonal">
<span id="id1"></span><h2>5.1 非函数式编程<a class="headerlink" href="#lisp-is-not-funcitonal" title="Permalink to this heading"></a></h2>
<p>对 Lisp 常见的一种偏见是将其叫做函数式编程语言。但 lisp 不是函数式语言。事实上，
lisp 是有史以来最不像函数式的语言。这个误解的根源很有趣，同时也是个很好例子，
说明了一个小的用词不当可以产生持久的影响，并在用词不当的原因变得无关紧要之后
很长时间内导致混淆。什么是函数式编程语言呢？唯一有意义的定义是:</p>
<blockquote>
<div><p>函数式编程语言是由函数构成的语言</p>
</div></blockquote>
<p>那么，什么是函数呢？函数是数学中的一个概念，已经存在了几个世纪:</p>
<blockquote>
<div><p>函数是一个静态的，定义好的从输入到输出的映射关系</p>
</div></blockquote>
<p>在 lisp 中，我们使用 <strong>defun</strong> 来定义新函数。例如，下面的函数使用求和将所有数字
的集合映射到一个新集合，这个新集合也包括所有数字：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(defun adder (x)
  (+ x 1))
</pre></div>
</div>
<p>显然，我们可以将这段代码应用于任意数字，获得映射后得到的返回值，但 <strong>adder</strong>
真的是个函数吗？好吧，令人困惑的是，lisp 认为它是：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>* (describe #&#39;adder)
#&lt;Interpreted Function&gt; is a function.
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>如果你之前没有在 Common Lisp 中见过 <strong>describe</strong> 函数的话，现在可以试一下。
该函数是返回函数、特殊表格、宏、变量、符号以及闭包的描述。</p>
</div>
<p>但是把 <strong>adder</strong> 称为函数是 lisp 历史中最根深蒂固的误解之一。<strong>defun</strong> 和 lambda
表达式实际上创建的是个过程（procedures），或者更确切的说，一个可被调用的实例。
这有什么区别呢？过程不一定与值的映射有任何关系，而是可执行的代码段（函数调用），
可能是保存的环境变量。当 lisp 程序员用 <em>函数式风格</em> 来写代码时，之后就导致过程
能被认为是数学风格的函数映射，同时可以将过程组合在一起来假装成函数映射。</p>
<p>Lisp 之所以经常被误称为函数式编程语言是有历史原因的。信不信由你，有段时间大部分
语言甚至都不支持过程这一概念，而现代程序员认为在所有的语言中过程是理所当然的。早期
的一些语言在可复用的代码中并没有提供给局部变量合适的抽象，程序员们只能通过手动分配
寄存器和操作堆栈来实现这中操作。Lisp，至始至终就有过程，似乎比那些语言更具备函数式的特性。</p>
<p>接下来，过程抽象得到应有的重视，并被纳入几乎所有编程语言，随后大家就开始慢慢地
遇到障碍，因为他们所实现的过程的性质有限。然后程序员们开始意识到，他们可以从其
他的过程中返回过程、把它们嵌入到新的环境中、聚合到一个数据结构中，或者更通用的
是，将过程作为任意常规的值。于是就出现了个口号来动员程序员进行下一代的大抽象推
进：a society without classes, first-class procedures。与那些将过程降
级到次等二级类的语言相比，lisp，这种一直拥有这些一级过程的语言，似乎更具被函数式
的特性。</p>
<p>最后，大部分语言为了支持某些糟糕的 _Blub_ 语法（如中缀赋值），在表达式和语句之间
做了无意义的区分。在 lisp 中，语句都会返回某些值，同时对代码的嵌套和组合也没有任
何限制（语法方面）。这是个很简单的问题，答案也显而易见：在一门语言中，对新手友
好的语法和真正的灵活性哪个更重要？中缀语法的语言在许多方面降低了其抽象的可能性。
幸运的是，大多数现代语言决定给予用户足够的信任，允许他们根据自己的需要来组合表
达式。与那些做出这些脑残语法决定的语言相比，lisp 看起来更具备函数式的特性。</p>
<p>在熟悉了这个普遍存在但却被误导的术语之后，程序员们开始意识到，在函数式编程语言
和非函数式编程语言之间的争论中使用的函数概念不仅令人困惑，同时也是本末倒置。
为了纠正这个错误，程序员和学者们都回到黑板前，回到了函数的数学定义：从输入到输出
的映射。如果 lisp 在某种程度上是函数式语言，那么它与Perl 和 Javascript 等现代语言一样。</p>
<p>显然，lisp 过程不是函数。Lisp 过程可以返回非静态值，也就是说，可以使用相同的参数
多次调用，每次接收不同的返回值。就像我们前面章节的例子一样，lisp过程可以通过封装
变量来存储状态。<strong>rplaca</strong> 这样的过程可以改变内存或其他地方（如寄存器）中的值。
<strong>terpri</strong> 和 <strong>format</strong> 这样的 lisp 过程会产生指向终端或文件的输出（在 <strong>terpri</strong> 情况
下是换行）。<strong>yes-or-no-p</strong> 这样的 lisp 过程会从终端中读取输入，然后根据输入返回
对应的值。难道这些过程都是静态的、定义好的映射吗？</p>
<blockquote>
<div><p><strong>Terpri</strong> 和 <strong>rplaca</strong> 这两个操作符都合理地阐述了 COMMON LISP 操作符糟糕命名的区别</p>
</div></blockquote>
<p>因为 lisp 过程不是数学函数，所以 lisp 也就不是函数式编程语言。事实上，一个强有力
的论点是 lisp 比大多数其他语言更不像函数式。大部分语言中，看起来像过程调用的表
达式都是被语言的语法强制为过程调用。而在 lisp 中，我们有宏。正如我们所看到的，
宏可以隐式地将某些形式的含义从函数调用改变为 lisp 表达式，这种技术在许多方面
违反了引用透明性，这在其他语言中是不可能的。</p>
<p>考虑到大多数语言实际上根本不是函数式的，一些语言设计者决定弄清楚在真正的函数式
语言中编程是什么样子的。不出所料，编程函数式语言大多是令人讨厌和不切实际的。
从输入值到输出值的静态、定义良好的映射几乎不能有效地表示现实世界中的问题。也就
是说，函数式编程并非没有优点，许多语言都被设计为利用函数式编程风格。这意味着找
到一种方便的方法，将程序的功能部分与(实际上有趣的)非功能部分隔离开来。<strong>Haskell</strong>
和 <strong>Ocaml</strong> 这样的语言就是使用这种隔离作为进行积极优化假设的方法。</p>
<p>但这是 lisp。我们很不函数式并以此为豪。在某种程度上，这种副作用的隔离很有用，lisp
程序员可以并且确实能使用宏来实现它。函数式编程背后真正的目的是将应该发生什么的
函数描述与实际发生的机制分离开来。Lisp 肯定不是函数式，但由于宏的存在，没有比
Lisp 更好的实现函数式语言的平台或工具。</p>
</section>
<section id="topdown-programming">
<span id="id2"></span><h2>5.2 自上而下的编程<a class="headerlink" href="#topdown-programming" title="Permalink to this heading"></a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>你教不会初学者自顶向下编程，因为他们不知道哪一端是上。 --C.A.R. Hoare
</pre></div>
</div>
<p>在 <a class="reference internal" href="chapter03.html#domain-specific"><span class="std std-ref">3.2 领域特定语言</span></a> 中，当我们第一次考虑特定域语言时，我们创建了个简单
的宏 <strong>unit-of-time</strong> 。这个宏允许我们用一种直观的、基于符号的语法，可以方便地以不
同的单位指定时间段：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>* (unit-of-time 1 d)

86400
</pre></div>
</div>
<p><strong>unit-of-time</strong> 是个很方便的特定域语言，因为程序员不必去记住一些东西，比如说，一天
有多少秒。<strong>unit-of-time</strong> 是用简单的宏实现的，该宏使用 case 语句作为底层展开的核心。</p>
<p>宏设计的一个重要原则就是自上而下编程。设计一个 lisp 宏时，首先要从抽象开始。你需要
在编写这个宏之前就想要使用这个宏。有点矛盾的是，在为该语言编写简洁的定义/实现之前，
你需要知道怎么用这个语言编程。</p>
<p>因此，构造个正规的宏的第一步是编写宏的用例，即使无法测试或使用它们。如果用新语言编
写的程序足够全面的话，那么接下来就会有个很棒的想法，即该语言实现编译器或解释器需要
什么。</p>
<p>回到 <strong>unit-of-time</strong> 宏，有没有办法将它提升到另一个级别的规格，并创建一种语言来创建
这些单位的方便的宏呢？好吧，<strong>unit-of-time</strong> 是个宏，为了实现目的就需要用宏来定义宏……</p>
<p>停！到此为止。</p>
<p>我们不是从考虑语言的实现开始的，而是问我们自己要用这个语言做什么。答案是我们想要个
简单的方法，用来定义这类帮助转换单位的工具。以下这个示例中，我们希望使用一种单位类
型——时间，其基本单位为：秒，用 <strong>s</strong> 来指代，以及一组单位和这个单位到基本单位的转换
因子：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(defunits% time s
  m 60
  h 3600
  d 86400
  ms 1/1000
  us 1/1000000)
</pre></div>
</div>
<p><strong>defunits%</strong> 会展开成定义宏的代码，就像在 <a class="reference internal" href="chapter03.html#domain-specific"><span class="std std-ref">3.2 领域特定语言</span></a> 中编写的
<strong>unit-of-time</strong> ，允许我们将任意的时间单位转换为秒。还能写的更好吗？</p>
<p>在设计头脑风暴中，创新在大多数编程语言中都停滞不前。刚刚我们创建了一种将不同单位的
乘数值映射到代码中的方法，这种方法让我们能够方便地转换单位。但作为一个专业的 lisp
程序员会意识到这个映射本身就是一个程序，并且可以用我们经常增强 lisp 程序的方法来增
强它。当我们输入多种不同的单位是，用来指定对应的单位就会很有用。现在，让我们定义
个因子，这个因子用来增加单位的种类，可以是一个列表，该列表中的值与单位相对应，如
下所示：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(defunits%% time s
  m 60
  h (60 m)
  d (24 h)
  ms (1/1000 s)
  us (1/1000 ms))
</pre></div>
</div>
<p>上面这个单位的列表看起来就比较自然了。我们以分钟为基础单位，秒、时基于分钟，天基
于小时。为了使用迭代的方法实现这个宏，首先需要用 <strong>defunits%</strong> 来实现非链的版本，
然后用 <strong>defunits%%</strong> 实现链版本，最后添加适当的错误检查，就有了最终的版本：
<strong>defunits</strong>。</p>
<p>注意，这种新语言可以提供更多方便的语法来添加新的单元类型。这种语言还允许我们延迟
四舍五入对计算的影响，并允许 lisp 使用尽可能精确的算法。例如, furlong 相当于 1/8 英
里，所以我们使用链版本来对其进行编码，也就是说，近似的距离，就可以得到更准确的
结果，或者说更重要的是，与其他计算结果尽可能保持一致，都使用英里做单位。这是因为
我们可以添加找到的最精确的转换因子，而不需要自己进行任何转换，宏让我们在其他语言
中无法实现的表达式级别上构建转换例程。</p>
<p>使用 <a class="reference internal" href="chapter03.html#unwanted-capture"><span class="std std-ref">3.5 异常捕获</span></a> 中的 <strong>gensym</strong> ，<strong>defunits%</strong> 就很容易编写。
Graham 的 <strong>symb</strong> 函数可以将转换宏生成个新的名字。例如，当 <strong>time</strong> 是内置的表示单位，
那么转换宏就是 <strong>unit-of-time</strong>。 <strong>defunits%</strong> 是由最初定义的 <strong>unit-of-time</strong> 构建
的，<strong>unit-of-time</strong> 是在 <a class="reference internal" href="chapter03.html#domain-specific"><span class="std std-ref">3.2 领域特定语言</span></a> 中定义的，在 <strong>defunits%</strong> 中，
由 <strong>defmacro!</strong> 和反引号组成，用来替换宏调用时需要重新生成的部分。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Graham 是 On Lisp 的作者，会经常出现一些上面的内容，如果有时间的话，推荐去看一下这本书。</p>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(defmacro! defunits% (quantity base-unit &amp;rest units)
  `(defmacro ,(symb &#39;unit-of-quantity) (,g!val ,g!un)
    `(* ,,g!val
        ,(case ,g!un
          ((,base-unit) 1)
          ,@(mapcar (lambda (x)
                      `((,(car x)) ,(cadr x)))
                    (group units 2))))))
</pre></div>
</div>
<p><strong>defunits%</strong> 用了反引号（<strong>`</strong>）嵌套：一个非常难以理解的结构。用反引号编程就像在代码
中增加了一个维度的含义。在其他的语言中，给定的语句通常都有非常简单的语义计算。你能
清除的指导每段代码会在什么时候执行，因为每段代码都必须同一时间执行：运行时（run-time）。
但在 lisp 中，我们可以通过反引用嵌套来缩放引用的梯度。每次使用反引号时，都将我们的
梯度往上提了一级：反引号内的代码是一个列表，之后这个列表可能会被求值也可能不会。
但在里面的原始列表中，每遇到逗号时，有会将我们会回到上一个引用梯度，然后以合适的方式
执行对应梯度的代码。</p>
<p>因此，有一种简单的算法可以确定何时 lisp 代码会被求值。只需从表达式的根开始，在遇到
反引号后，标记一层引号。每遇到一个逗号，就把引号调低一级。正如 Steel 所指出的，
遵循这种级别的引用很具挑战性。追踪当前引用深度的这种困难，让使用反引用感觉像是在
常规编程中添加了另一个维度。在其他语言中，可以随意向“东南西北”四个方向走，但 lisp
还提供了向上的选择。</p>
<p><strong>defunits%</strong> 是个好的开始，但却没有实现链。目前，实现该语言的宏主要是简单的替换。
要实现链行为需要更复杂的程序逻辑。简单的替代不起作用，因为宏的部分依赖于宏的其
他部分，所以在扩展时，需要完整地处理提供给宏的表单，而不仅仅是考虑可以插入的各
个部分。</p>
<p>记住，宏实际上就是函数，现在来创建了一个实用函数在宏定义中使用：<strong>defunits-chaining%</strong>。
这个实用函数接收一个单位，例如像 <strong>S</strong>、<strong>M</strong> 或是 <strong>H</strong> 这样的符号，同时接收该单位规格
列表。这个单位规格既可以是单个数字，这个数字被解释为基础单位，如 <strong>(M 60)</strong>，
也可以是一个列表，该列表内部链式地指向另一个单位，如 <strong>(H (60 M))</strong>。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(defun defunits-chaining% (u units)
  (let ((spec (find a units :key #&#39;car)))
    (if (null spec)
      (error &quot;Unknown unit ~a&quot; u)
      (let ((chain (cadr spec)))
        (if (listp chain)
          (* (car chain)
              (defunits-chaining%
                (cadr chain)
                units))
          chain)))))
</pre></div>
</div>
<p>这个实用函数是递归的。为了求基本单位的乘数，我们将链中的每一步乘以另一个实用
函数的调用，从而算出链的其余部分。当调用堆栈返回时，就会得到将给定单元的值转
换为基本单元的乘数。例如，在构建小时的乘数时，可以求得一小时是六十分钟，然后
递归得到一分钟是六十秒，再次递归时发现秒是这条链的末尾，然后就会直接将分钟设
为基础单位。因此，递归堆栈返回需要计算的是：<strong>(* 60 (* 60 1))</strong>，也就是
<strong>3600</strong>，这样就得到了一小时等于 3600 秒。</p>
<p>有了这个实用函数后，计算每个单位之间的乘数只需要对 <strong>defunits%</strong> 进行简单的修改，
如下面的 <strong>defunits%%</strong>。我们不是直接从单元规格中拼接值，而是将每个单元和整个单
元规格传给 <strong>defunits-chaining%</strong> 实用程序。如上所述，这个函数递归地计算出将每
个单元转换为基本单元所需的乘数。通过这个乘数， <strong>defunits%%</strong> 可以像 <strong>defunits%</strong>
一样拼接到 <strong>case</strong> 语句中。</p>
<p>然而，这些宏并不完整。<strong>defunits%</strong> 宏不支持链式。 <strong>defunits%%</strong> 支持链式，但没有
错误检查。专业的宏编写人员总是小心地处理任何可能出现的错误条件。在无限循环或是
在 REPL 中难以调试的情况中，错误检查尤为重要。</p>
<p><strong>defunits%%</strong> 的问题实际上是我们设计的语言的一个属性：可以编写有环的程序。如：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(defunits time s
  m (1/60 h)
  h (60 m))
</pre></div>
</div>
<p>为了提供适当的调试输出，需要稍微增强实现。最终的版本，<strong>defunits</strong>：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(defun defunits-chaining (u units prev)
  (if (member u prev)
    (error &quot;~{ ~a~~ depends on ~}&quot;
      (cons u prev)))
  (let ((spec (find u units :key #&#39;car)))
    (if (null spec)
      (error &quot;Unknown unit ~a&quot; u)
      (let ((chain (cadr spec)))
        (if (listp chain)
          (* (car chain)
            (defunits-chaining
              (cadr chain)
              units
              (cons u prev)))
          chain)))))

(defmacro! defunits (quantity base-unit &amp;rest units)
  `(defmacro ,(symb &#39;unit-of- quantity)
            (,g!var ,g!un)
    `(* ,,g!val
        ,(case ,g!un
          ((,base-unit) 1)
          ,@(mapcar (lambda (x)
                      `((,(car x))
                          ,(defunits-chaining
                              (car x)
                              (cons
                                `(,base-unit 1)
                                (group units 2))
                              nil)))
                      (group units 2))))))
</pre></div>
</div>
<p><strong>defunits</strong> 不但支持链式，而且如果该语言的用户指定了具有这种循环依赖关系的程序，
它还提供了有用的调试输出。之所以能做到是因为使用了 <strong>defunits-chaining</strong>——
<strong>defunits-chaining%</strong> 的升级版，<strong>defunits-chaining%</strong> 维护了以前访问过的所
有单元的列表。这样，当再次通过链式访问同一个单位时，就会抛出异常来简明的描述
这个问题:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>* (defunits time s
    m (1/60 h)
    h (60 m))

Error in function DEFUNITS-CHAINING:
  M depends on H depends on M
</pre></div>
</div>
<p><strong>defunits</strong> 宏与 <strong>defunits%%</strong> 完全相同，除了传递了个额外的参数 <strong>nil</strong> 给
<strong>defunits-chain</strong>，这是表示已经到了访问过的单位记录列表的末尾。如果一个
新单位被搜索，而我们已经访问过它，那么一个环就被检测到了。我们可以用这个
访问过的单元历史记录来向宏的用户（很可能是我们自己）显示有用的信息，这些
用户可能无意中写入了环。</p>
<p>因此，<strong>defunits</strong> 是种将单元输入到转换例程领域的专用语言。实际上，它精确
到更细的领域；也有很多可能的写法。由于在 <strong>Blub</strong> 中创建语言很困难，而在
lisp 中却很容易，所以lisp程序员通常不会把所有东西都塞到一个域中。相反，
它们只是使语言越来越精确到问题领域，直到问题变得很细致。</p>
<p>使用 <strong>defunits</strong> 的例子是 <strong>unit-of-distance</strong>。</p>
<div class="highlight-lisp notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nv">defunits</span><span class="w"> </span><span class="nv">distance</span><span class="w"> </span><span class="nv">m</span><span class="w"></span>
<span class="w">  </span><span class="nv">km</span><span class="w"> </span><span class="mi">1000</span><span class="w"></span>
<span class="w">  </span><span class="nv">cm</span><span class="w"> </span><span class="m">1/100</span><span class="w"></span>
<span class="w">  </span><span class="nv">mm</span><span class="w"> </span><span class="p">(</span><span class="m">1/10</span><span class="w"> </span><span class="nv">cm</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="nv">nm</span><span class="w"> </span><span class="p">(</span><span class="m">1/1000</span><span class="w"> </span><span class="nv">mm</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="nv">yard</span><span class="w"> </span><span class="m">9144/10000</span><span class="w">  </span><span class="c1">; Defined in 1956</span><span class="w"></span>
<span class="w">  </span><span class="nv">foot</span><span class="w"> </span><span class="p">(</span><span class="m">1/3</span><span class="w"> </span><span class="nv">yard</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="nv">inch</span><span class="w"> </span><span class="p">(</span><span class="m">1/12</span><span class="w"> </span><span class="nv">foot</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="nv">mile</span><span class="w"> </span><span class="p">(</span><span class="mi">1760</span><span class="w"> </span><span class="nv">yard</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="nv">furlong</span><span class="w"> </span><span class="p">(</span><span class="m">1/8</span><span class="w"> </span><span class="nv">mile</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="nv">fathom</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="nv">yard</span><span class="p">)</span><span class="w">  </span><span class="c1">; Defined in 1929</span><span class="w"></span>
<span class="w">  </span><span class="nv">nautical-mile</span><span class="w"> </span><span class="mi">1852</span><span class="w"></span>
<span class="w">  </span><span class="nv">cable</span><span class="w"> </span><span class="p">(</span><span class="m">1/10</span><span class="w"> </span><span class="nv">nautical-mile</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="nv">old-brit-nautical-mile</span><span class="w">  </span><span class="c1">; Dropped in 1970</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="m">6080/3</span><span class="w"> </span><span class="nv">yard</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="nv">old-brit-cable</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="m">1/10</span><span class="w"> </span><span class="nv">old-brit-nautical-mile</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="nv">old-brit-fathom</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="m">1/100</span><span class="w"> </span><span class="nv">old-brit-cable</span><span class="p">))</span><span class="w"></span>
</pre></div>
</div>
<p>如果你想知道的话，1970 年采用国际海里制缩短了英寻（至少对英国水手而言）
的 1/76，也就 2 厘米多一点：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>* (/ (unit-of-distance 1 fathom)
    (unit-of-distance 1 old-brit-fathom))
* (coerce
    (unit-of-distance 1/76 old-brit-fathom)
    &#39;float)

0.024384
</pre></div>
</div>
</section>
<section id="implicit-contexts">
<span id="id3"></span><h2>5.3 隐式上下文<a class="headerlink" href="#implicit-contexts" title="Permalink to this heading"></a></h2>
<p>宏可以使用隐式上下文的技术。在常用的代码中，或者说是需要绝对简洁且没有很细节的代码中，
有时要隐式地在表达式的某些部分添加 lisp 代码，这样就不必每次使用抽象时都去编写它。之前
也有介绍过隐式上下文，而且也很清楚的表达了，即便是不使用宏，隐式上下文也是 lisp 编程的
基础部分： <strong>let</strong> 和 <strong>lambda</strong> 表达式就有个隐式的 <strong>progn</strong>。因为这两个表达式是顺序的执
行表达式的主题并返回最后的那个结果。<strong>defun</strong> 会在表达式外添加隐式的 <strong>lambda</strong>，因此不需
要在已命名的函数中使用 lambda 格式。</p>
<p>本节介绍的是本书中后面要用到的遍历代码的宏——<strong>tree-leaves</strong> 的推导以及构造。和
<strong>flatten</strong> 一样，<strong>tree-leaves</strong> 宏会检查一段 lisp 代码，将这段代码当作一个树
（<strong>tree</strong>），然后做一些改动后返回一个新树。原表达式的列表结构不会被更改：<strong>flatten</strong> 和
<strong>tree-leaves</strong> 都是构建新的结构。这两者之间的不同之处在于，<strong>flatten</strong> 会将嵌套列表
中的嵌套移除然后返回一个不是真正的 lisp 的扁平（<strong>flat</strong>）列表，而 <strong>tree-leaves</strong> 则是
保留了表达式的结构，但修改了特定原语（<strong>atom</strong>）的值。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>这里的树指的是数据结构中的树。原语指的是一个词，为最小单位，不可再分割。
具体参考: <a class="reference external" href="https://www.gnu.org/software/emacs/manual/html_node/eintr/Lisp-Atoms.html">https://www.gnu.org/software/emacs/manual/html_node/eintr/Lisp-Atoms.html</a></p>
</div>
<p>现在，先从简单的初稿开始吧。<strong>tree-leaves%</strong> 是个函数，</p>
<div class="highlight-lisp notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">tree-leaves%</span><span class="w"> </span><span class="p">(</span><span class="nv">tree</span><span class="w"> </span><span class="nv">result</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="nv">tree</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">listp</span><span class="w"> </span><span class="nv">tree</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="nb">cons</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="nv">tree-leaves%</span><span class="w"> </span><span class="p">(</span><span class="nb">car</span><span class="w"> </span><span class="nv">tree</span><span class="p">)</span><span class="w"></span>
<span class="w">                      </span><span class="nv">result</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="nv">tree-leaves%</span><span class="w"> </span><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="nv">tree</span><span class="p">)</span><span class="w"></span>
<span class="w">                      </span><span class="nv">result</span><span class="p">))</span><span class="w"></span>
<span class="w">      </span><span class="nv">result</span><span class="p">)))</span><span class="w"></span>
</pre></div>
</div>
<p>该函数会递归的去遍历提供的 <strong>tree</strong> 表达式参数，然后将同类型的构造成列表结构。
当遇到原语时，函数会返回 <strong>result</strong> 参数的值，而不是返回原语的值：</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>在 <strong>if</strong> 结构中，如果 <strong>else</strong> 部分没有的话，那么 <strong>else</strong> 的部分就返回 <strong>nil</strong>，
即空列表。</p>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>* (tree-leaves%
    &#39;(2 (nil t (a . b)))
    &#39;leaf)

(LEAF (NIL LEAF (LEAF . LEAF)))
</pre></div>
</div>
<p>所以，<strong>tree-leaves%</strong> 返回了个新的树结构，其中所有的原语都被转换成了提供的
参数 <strong>leaf</strong>。注意，<strong>cons</strong> 结构中 <strong>car</strong> 位置的原语 <strong>nil</strong> 没有变，和 <strong>cdr</strong> 位置
一样，都不会变( <strong>cdr</strong> 为 <strong>nil</strong> 时即表示空列表）。</p>
<p>当然，更改每个元素是没有什么意义的。我们真正想要的是一种选择特定原语的方法，
并选择性地对其进行转换，之后再将转换后的原语插入到新的列表结构中，对不相关
的就不用去管他了。在 lisp 中，编写个可自定义的使用函数的最直接的方法就是有插
件——即用户可以使用自定义的代码来控制实用程序的功能。<strong>COMMON LISP</strong> 内置的
<strong>sort</strong> 函数就是典型的代表。以下的代码中，小于函数对 <strong>sort</strong> 来说就是个插件：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>* (sort &#39;(5 1 2 4 3 8 9 6 7) #&#39;&lt;)
(1 2 3 4 5 6 7 8 9)
</pre></div>
</div>
<p>使用函数作为参数来控制程序的行为的这个理念很方便，因为这样就可以创建写适合
手头任务的匿名函数。或者说，当需要更强大的功能时，可以创建个生成匿名函数的
函数。这种行为被称为函数组合（<strong>function composition</strong>）。尽管函数组合没
有宏组合（<strong>macro composition</strong>）那么有趣，但这仍是个很有用的技术，且这个
技术是专业 lisp 程序员必须掌握的。</p>
<p>有个关于函数组合的简单示例是 —— <strong>predicate-splitter</strong>。</p>
<div class="highlight-lisp notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">predicate-splitter</span><span class="w"> </span><span class="p">(</span><span class="nv">orderp</span><span class="w"> </span><span class="nv">splitp</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="nv">a</span><span class="w"> </span><span class="nv">b</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nv">s</span><span class="w"> </span><span class="p">(</span><span class="nb">funcall</span><span class="w"> </span><span class="nv">splitp</span><span class="w"> </span><span class="nv">a</span><span class="p">)))</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">eq</span><span class="w"> </span><span class="nv">s</span><span class="w"> </span><span class="p">(</span><span class="nb">funcall</span><span class="w"> </span><span class="nv">splitp</span><span class="w"> </span><span class="nv">b</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="nb">funcall</span><span class="w"> </span><span class="nv">orderp</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">b</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="nv">a</span><span class="p">))))</span><span class="w"></span>
</pre></div>
</div>
<p>该函数是将两个断言函数组合成一个新的断言。第一个断言函数接收两个参数，用来
排序。第二个断言接收一个参数，并确定元素是否符合需要分割的断言的特殊类别。
例如，下面这个例子就是用 <strong>predicate-splitter</strong> 来创建个新的断言，该断言
和小于判断工作原理是一致的，只不过该断言认为偶数要小于奇数：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>* (sort &#39;(5 1 2 4 3 8 9 6 7)
        (predicate-splitter #&#39;&lt; #&#39;evenp))

(2 4 6 8 1 3 5 7 9)
</pre></div>
</div>
<p>所以，要怎么样才能将函数作为插件来控制 <strong>tree-leaves%</strong> 工作呢？在
<strong>tree-leaves%</strong> 的更新版本 —— <strong>tree-leaves%%</strong> 中，添加了两个不同的函数
插件，一个用来控制哪些元素需要改变，另一个用来指明怎么将旧元素转换成新元
素，这两个函数分别称为测试（<strong>test</strong>）和结果（<strong>result</strong>）。</p>
<div class="highlight-lisp notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">tree-leaves%%</span><span class="w"> </span><span class="p">(</span><span class="nv">tree</span><span class="w"> </span><span class="nv">test</span><span class="w"> </span><span class="nv">result</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="nv">tree</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">listp</span><span class="w"> </span><span class="nv">tree</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="nb">cons</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="nv">tree-leaves%%</span><span class="w"> </span><span class="p">(</span><span class="nb">car</span><span class="w"> </span><span class="nv">tree</span><span class="p">)</span><span class="w"> </span><span class="nv">test</span><span class="w"> </span><span class="nv">result</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="nv">tree-leaves%%</span><span class="w"> </span><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="nv">tree</span><span class="p">)</span><span class="w"> </span><span class="nv">test</span><span class="w"> </span><span class="nv">result</span><span class="p">))</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">funcall</span><span class="w"> </span><span class="nv">test</span><span class="w"> </span><span class="nv">tree</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="nb">funcall</span><span class="w"> </span><span class="nv">result</span><span class="w"> </span><span class="nv">tree</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="nv">tree</span><span class="p">))))</span><span class="w"></span>
</pre></div>
</div>
<p>我们可以传给 <strong>tree-leaves%%</strong> 两个 lambda 表达式，这两个表达式都只接受单个
参数 —— <strong>x</strong>。在这种情况中，我们想要这么这样的新的树结构：该树的结构与传入
的参数 <strong>tree</strong> 相同，但是会将所有的偶数都变成 <strong>even-number</strong> 的符号：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>* (tree-leaves%%
    &#39;(1 2 (3 4 (5 6)))
    (lambda (x)
      (and (numberp x) (evenp x)))
    (lambda (x)
      &#39;even-number))

; Note: Variable X defined but never used.

(1 EVEN-NUMBER (3 EVEN-NUMBER (5 EVEN-NUMBER)))
</pre></div>
</div>
<p>除了有个纠正的提示 <strong>x</strong> 变量在第二个函数插件中没有用到外，函数看起来很正常。
当没有使用一个变量时，代码中通常都会有这么一个提示。即便是故意的，就像上面
代码那样，编译器也会将需要忽略的变量的信息输出。通常，我们都会使用这个变量，
但存在这么一些情况，就像上面的例子一样，实际上是不想用到这个变量。遗憾的是
我们必须要传给函数一个参数，毕竟不管怎么说我们都忽略了那个参数。这种情况
通常时在编写灵活的宏时会遇到。解决办法就是像编译器声明可以忽略变量 <strong>x</strong>。因为
声明一个变量是可忽略后再使用这个变量并没有什么危害，因此可以将两个变量 <strong>x</strong>
都声明为可忽略：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>* (tree-leaves%%
    &#39;(1 2 (3 4 (5 6)))
    (lambda (x)
      (declare (ignorable x))
      (and (numberp x) (evenp x)))
    (lambda (x)
      (declare (ignorable x))
      &#39;even-number))

(1 EVEN-NUMBER (3 EVEN-NUMBER (5 EVEN-NUMBER)))
</pre></div>
</div>
<p>这就是这个教程的有趣之处。看起来 <strong>tree-leaves%%</strong> 刚刚好，我们可以修改树结构
中的任意元素，通过提供的函数插件，该函数插件用来决定那个元素需要需改和改成什
么。在除 lisp 之外的编程语言中，改实用工具的优化就到此为止了。但在 lisp 中，
可以做的更好。</p>
<p>尽管 <strong>tree-leaves%%</strong> 中提供了我们想要的所有功能，但它的接口不是很方便而且
有点冗余。试用试用工具时越是简单，之后使用中就越能找到其有趣之处。为了减少
代码遍历实用工具的混乱，我们创建个宏，该宏为其用户（可能是我们自己）提供了
隐式上下文。</p>
<p>但我们需要的不是像隐式的 <strong>progn</strong> 或 <strong>lambda</strong> 那么简单，而是完整的隐式词法
上下文，用来节省创建这些插件函数的开销，并在运行转换树这样的常见任务时只需
要输入最少量的代码。</p>
<div class="highlight-lisp notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defmacro</span><span class="w"> </span><span class="nv">tree-leaves</span><span class="w"> </span><span class="p">(</span><span class="nv">tree</span><span class="w"> </span><span class="nv">test</span><span class="w"> </span><span class="nv">result</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">tree-leaves%%</span><span class="w"></span>
<span class="w">    </span><span class="o">,</span><span class="nv">tree</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="nv">x</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="k">declare</span><span class="w"> </span><span class="p">(</span><span class="k">ignorable</span><span class="w"> </span><span class="nv">x</span><span class="p">))</span><span class="w"></span>
<span class="w">      </span><span class="o">,</span><span class="nv">test</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="nv">x</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="k">declare</span><span class="w"> </span><span class="p">(</span><span class="nv">ignoreable</span><span class="w"> </span><span class="nv">x</span><span class="p">))</span><span class="w"></span>
<span class="w">      </span><span class="o">,</span><span class="nv">result</span><span class="p">)))</span><span class="w"></span>
</pre></div>
</div>
<p>该词法隐式上下文不像简单的隐式上下文，因为我们并没有找到通用隐式模式的另一
种用法。相反，在开发 <strong>tree-leaves%%</strong> 的遍历接口时，我们一步一步地开发了个
不太常见的模式。</p>
<p>对于隐式宏的结构，在之前的 REPL 中的 <strong>tree-leaves%%</strong> 直接有效地复制粘贴到
<strong>tree-leaves</strong> 的定义中，然后在我们期望根据宏的不的用途而进行修改的地方，
我们使用了反引号进行参数化。现在，通过这个宏，使用 <strong>tree-leaves%%</strong> 这个实
用工具时的冗余接口就更少了，当然，该接口是任意的，因为有多种编写的可能方式。
然而，这似乎是最直观的、最不臃肿的方法，至少就我们目前所设想的用途而言。宏
允许我们以一种简单、直接的方式创建个高效的程序员接口，这在其他语言中是不可
能的。下面是我们如何使用这个宏的例子：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>* (tree-leaves
    &#39;(1 2 (3 4 (5 6)))
    (and (numberp x) (evenp x))
    &#39;even-number)

(1 EVEN-NUMBER (3 EVEN-NUMBER (5 . EVEN-NUMBER)))
</pre></div>
</div>
<p>注意，变量 <strong>x</strong> 实际上是在没有定义的情况下就使用了。这是因为后面两个表达式都有
个隐式词法变量。这种不可见变量的引入被认为违反了词法透明性。另一种说法是，
引入了个名为 <strong>x</strong> 的重复词供这些形式使用。我们将在[第六章：回指(Anaphoric) 宏]
中进一步介绍。</p>
</section>
<section id="macrolet">
<span id="code-walking-with-macrolet"></span><h2>5.4 使用 <strong>macrolet</strong> 遍历代码<a class="headerlink" href="#macrolet" title="Permalink to this heading"></a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Lisp 不是门语言，而是构建语言的原料。 —— Alan Kay
</pre></div>
</div>
<p>像计算机代码，写出的表达式结构基本不会说话，，因此往往会有多种不同的发音习惯。大多数
程序员在脑中会有个对话，推理表达式和读出运算符，有时是有意识的，但大部分情况下是无意
识的。例如，lisp 的 <strong>macrolet</strong> 的发音最简单的方法就是把两个 lisp 关键字 （<strong>macro</strong> 和
<strong>let</strong>）连起来读。但看过 Steele 的 observation 后，部分程序员会用 <strong>Chevrolet</strong> 押韵的
方式来读 <strong>macrolet</strong>，这种幽默的发音很难从脑中的对话中去掉。</p>
<p>不管 <strong>macrolet</strong> 是怎么读的，它都是 lisp 高级编程里很重要的一部分。<strong>macrolet</strong> 是个特殊
的 COMMON LISP 结构，它在其封闭的词法作用域中引入新的宏。<strong>macrolet</strong> 的语法转换和
<strong>defmacro</strong> 定义全局的宏一样。就像 lisp 会在代码中展开以 <strong>defmacro</strong> 定义的宏，当 lisp
遍历代码中的表达式一样，<strong>macrolet</strong> 定义的宏也会被展开。</p>
<p>但 <strong>macrolet</strong> 的不止有这么点功能。与 <strong>defmacro</strong> 相比，<strong>macrolet</strong> 有很多重要的优
点。首先，如果你想要通过给定不同的表达式的内容让宏以不同的方式展开，就需要使用 <strong>macrolet</strong>
来创建不同的内容。而这是 <strong>defmarco</strong> 做不到的。</p>
<p>最重要的是，<strong>macrolet</strong> 很有用，因为遍历 COMMON LISP 表达式的代码很难。对任意的 lisp
代码树，假设是因为用宏在处理它，然后我们想要改变不同分支的值或含义。为了实现某些结构
的临时含义，以及临时重写某些特定宏（可能只是表达式词法上下文中特定部分），我们需要
遍历代码。具体来说，需要递归地遍历代码，在需要求值的位置查找所需的宏或函数名，然后
用自己的表达式替换他的位置。</p>
<p>很简单，对吧？难点在于，很多正常的 lisp 代码段会破坏原生的代码遍历的实现。假设我们想
要对一个函数执行的特定符号（ <strong>blah</strong> ）进行替换，当给出以下表达式时，就很容易看出替
换位置：</p>
<div class="highlight-lisp notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nv">blah</span><span class="w"> </span><span class="no">t</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p><strong>blah</strong> 所在的位置是表达式的函数位置，当表达式计算时，<strong>blah</strong> 会被调用，显然，我们需要
在这个时候对 <strong>blah</strong> 进行替换。目前来说还不错，但如果传入下面这个结构会怎么样呢？</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&#39;(blah t)
</pre></div>
</div>
<p>因为表达式是被引用的，所以上面的代码的意思是直接返回一个列表。这里进行替换的话就会
出错。所以我们的代码遍历器在遇到引号（<strong>’</strong>）时，必须停止，同时不会去替换引用的结构中
的内容。很好，这也很简单。但考虑一下其他无法展开 blah 的场景。假如 <strong>blah</strong> 是个词法
变量的变量名呢？</p>
<div class="highlight-lisp notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nv">blah</span><span class="w"> </span><span class="no">t</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="nv">blah</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>尽管 <strong>blah</strong> 是列表中的第一个位置，但这里它是 <strong>let</strong> 结构中的本地绑定，而这种绑定是不
会被展开的。但这也不算太糟糕。解决办法是可以在代码遍历器中添加一些特殊的逻辑，这样
代码遍历器就知道在遇到 <strong>let</strong> 结构时该怎么处理。不幸的是，ANSI COMMON LISP 中还有
23 个这种的特殊结构，这些结构也需要添加特定的逻辑。更重要的是，许多特殊结构很复杂，
不能正确的进行遍历。 正如上面所见的 <strong>let</strong>，比较棘手，而且还有更糟的情况。下面一段
合规的 COMMON LISP 代码结构中有个 <strong>blah</strong> 需要展开。但是具体是哪一个呢？</p>
<div class="highlight-lisp notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">(</span><span class="nv">blah</span><span class="w"> </span><span class="p">(</span><span class="nv">blah</span><span class="w"> </span><span class="p">(</span><span class="nv">blah</span><span class="w"> </span><span class="nv">blah</span><span class="p">)))</span><span class="w"></span>
<span class="w">  </span><span class="nv">blah</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>所以说遍历代码是很难的，因为要正确地处理特殊结构很难（见 [special-forms] 和
[USEFUL-LISP-ALGOS]）。注意，对定义为宏的结构，我们不会要特殊的逻辑。在遇到宏时，
可以简单地展开它，直到它变成函数调用或特殊的结构。如果是个函数的话，我们知道函数
遵循 lambda 从左到右且仅执行一次的语义。这才是需要开发特定的逻辑来处理的特殊结构。</p>
<p>听起来有很多工作要做，不是吗？事实确实是这样的。完整的 COMMON LISP 代码遍历器，
尤其是设计成可移植时，是段庞大且复杂的代码。那为什么 COMMON LISP 不提供个接口来
遍历 COMMON LISP 的代码呢？Emm，在某种程度上，COMMON LISP 确实提供了这个接
口，而这个接口的就叫做 <strong>macrolet</strong>。代码遍历正是Common Lisp系统在计算或编译表达式
之前需要做的事情。就像我们假设的代码遍历器一样，COMMON LISP 需要理解并处理 <strong>let</strong>
和其他特殊结构的特殊语义。</p>
<p>因为 COMMON LISP 在执行代码时需要遍历这些代码，所以没必要写一个单独的代码遍历器。
如果想要对表达式选择性转换，以一种智能的方式来计算实际需要计算的内容，可以将这个转换
打包成宏，然后使用 <strong>macrolet</strong> 结构将这个表达式包裹起来。当这个表达式被执行或编译时，
COMMON LISP 会遍历其代码，然后应用由 <strong>macrolet</strong> 指定的宏转换。当然，由于
<strong>macrolet</strong> 定义了这些宏，所以它不会在运行时增加任何额外的开销。<strong>macrolet</strong> 用于与
COMMON LISP 的代码遍历程序通信，而 COMMON LISP 对宏何时展开的唯一保证是它将在
编译函数的运行时之前完成。</p>
<p>使用 <strong>macrolet</strong> 最常见的一个场景就是，当你想假装一个函数绑定在某个词法上下文中，
但希望使用这个结构的行为不是函数调用。<strong>flet</strong> 和 <strong>labels</strong> 就不行了：他们只能定义
函数。所以我们选择写个代码遍历器来调用该函数，并将其替换为别的，用 <strong>defmacro</strong>
定义一个全局宏所以该“函数”会展开成别的，或是将这个结构嵌在 <strong>macrolet</strong> 中然后让
系统的代码遍历器来执行。</p>
<p>综上所述，实现个代码遍历器很难。如果可以的话，最好是避开这条路。用全局的
<strong>defmacro</strong> 有时可以实现，但通常都有问题。最大的问题是 COMMON LISP 无法保证
宏展开的时间或频率，因此无法可靠地在不同的词法上下文中使相同的变量名具有不同的
含义。当重写全局宏时，我们无法确定 COMMON LISP 之前使用该宏是否已经展开过，
或者之后是不是还需不需要再次进行展开。</p>
<p>为了举例说明这种代码遍历的用处，让我们重新讨论在 <a class="reference internal" href="chapter03.html#control-structures"><span class="std std-ref">3.3 控制结构</span></a> 中忽略
的问题。名为 <strong>nlet</strong> 的 Scheme 初始版本的 <strong>let</strong> 宏，是用 <strong>label</strong> 这个特定的结构
创建了个新的控制结构类型。<strong>labels</strong> 的这种用法允许我们临时定义函数，以便在
<strong>let</strong> 主题中使用，该函数允许递归，就像在 <strong>let</strong> 绑定中再次使用 <strong>let</strong> 绑定新的值
一样。当定义这个函数时，我们提到，因为 COMMON LISP 不能保证它将优化掉尾调用，
所以这个 <strong>let</strong> 控制结构每次迭代都可能会占用不必要的额外堆栈空间。换句话说，不同
于 Scheme，COMMON LISP 函数调用不能保证是优化的尾部调用。</p>
<p>即使大部分像样的 COMMON LISP 编译器都会执行适当的尾部调用优化，有时我们需要
确认优化已经进行了。最简单的、可移植的实现方法是修改 <strong>nlet</strong> 宏，这样它生成展开
时就不会使用不必要的堆栈空间。</p>
<div class="highlight-lisp notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nv">defmacro!</span><span class="w"> </span><span class="nv">nlet-tail</span><span class="w"> </span><span class="p">(</span><span class="nv">n</span><span class="w"> </span><span class="nv">letargs</span><span class="w"> </span><span class="k">&amp;rest</span><span class="w"> </span><span class="nv">body</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nv">gs</span><span class="w"> </span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="nv">for</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">letargs</span><span class="w"></span>
<span class="w">                  </span><span class="nv">collect</span><span class="w"> </span><span class="p">(</span><span class="nb">gensym</span><span class="p">))))</span><span class="w"></span>
<span class="w">    </span><span class="o">`</span><span class="p">(</span><span class="k">macrolet</span><span class="w"></span>
<span class="w">      </span><span class="p">((</span><span class="o">,</span><span class="nv">n</span><span class="w"> </span><span class="o">,</span><span class="nv">gs</span><span class="w"></span>
<span class="w">          </span><span class="o">`</span><span class="p">(</span><span class="k">progn</span><span class="w"></span>
<span class="w">            </span><span class="p">(</span><span class="nb">psetq</span><span class="w"></span>
<span class="w">              </span><span class="o">,@</span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nf">#&#39;</span><span class="nb">nconc</span><span class="w"></span>
<span class="w">                      </span><span class="p">(</span><span class="nb">mapcar</span><span class="w"></span>
<span class="w">                        </span><span class="nf">#&#39;</span><span class="nb">list</span><span class="w"></span>
<span class="w">                        </span><span class="ss">&#39;,</span><span class="p">(</span><span class="nb">mapcar</span><span class="w"> </span><span class="nf">#&#39;</span><span class="nb">car</span><span class="w"> </span><span class="nv">letargs</span><span class="p">)</span><span class="w"></span>
<span class="w">                        </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="o">,@</span><span class="nv">gs</span><span class="p">))))</span><span class="w"></span>
<span class="w">            </span><span class="p">(</span><span class="k">go</span><span class="w"> </span><span class="o">,</span><span class="ss">&#39;,g!n</span><span class="p">))))</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="k">block</span><span class="w"> </span><span class="o">,</span><span class="nv">g!b</span><span class="w"></span>
<span class="w">          </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="o">,</span><span class="nv">letargs</span><span class="w"></span>
<span class="w">            </span><span class="p">(</span><span class="k">tagbody</span><span class="w"></span>
<span class="w">              </span><span class="o">,</span><span class="nv">g!n</span><span class="w"> </span><span class="p">(</span><span class="k">return-from</span><span class="w"></span>
<span class="w">                    </span><span class="o">,</span><span class="nv">g!b</span><span class="w"> </span><span class="p">(</span><span class="k">progn</span><span class="w"> </span><span class="o">,@</span><span class="nv">body</span><span class="p">))))))))</span><span class="w"></span>
</pre></div>
</div>
<p>在 <strong>nlet-tail</strong> 中，我们将宏的主体嵌在了一些其他的结构中。我们用 <strong>block</strong> 和
<strong>return-from</strong> 语句来返回最后那个表达式的值，因为我们想要模拟 <strong>let</strong> 结构的行为
和它的隐式 <strong>progn</strong>。注意我们在 <strong>block</strong> 中用了 <strong>gensym</strong> 变量名，同时在每个 <strong>let</strong>
中都用 <strong>gensym</strong> 生成参数名，这样可以避免不必要的异常捕获，然后用 <strong>loop</strong> 宏将这
些 <strong>gensyms</strong> 汇集起来。</p>
<p><strong>nlet-tail</strong> 和我们最初的 <strong>nlet</strong> 的结构是一样的，除了非尾部的 <strong>let</strong> 结构调用被
禁用，因为这些 <strong>let</strong> 结构会展开成尾部调用。下面是个和介绍 <strong>nlet</strong> 是使用一样无趣
的例子，不同的是这个例子中可以保证，即使在不执行尾部调用优化的 lisp 中，也不会
消耗额外的堆栈空间。</p>
<div class="highlight-lisp notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">nlet-tail-fact</span><span class="w"> </span><span class="p">(</span><span class="nv">n</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="nv">nlet-tail</span><span class="w"> </span><span class="nv">fact</span><span class="w"> </span><span class="p">((</span><span class="nv">n</span><span class="w"> </span><span class="nv">n</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">acc</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">zerop</span><span class="w"> </span><span class="nv">n</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="nv">acc</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="nv">fact</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="nv">n</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="nv">acc</span><span class="w"> </span><span class="nv">n</span><span class="p">)))))</span><span class="w"></span>
</pre></div>
</div>
<p>因为这是本节的示例，注意，我们用 <strong>macrolet</strong> 对提供的内容进行代码遍历，来查找
<strong>fact</strong>。在之前的 <strong>nlet</strong> 用 <strong>labels</strong> 来制定结构绑定函数的地方，我们希望确保在调用
<strong>let</strong> 结构时不会消耗额外的堆栈空间。从技术上来说，我们希望修改词法环境中的一些
绑定，然后跳转回这个 <strong>let</strong> 结构的顶部。因此 <strong>nlet-tail</strong> 接受上面示例中 <strong>let</strong> 的
名称，并创建个本地宏，该宏只在对应的代码主体中生效。这个宏展开的代码中，使用
<strong>psetq</strong> 将 <strong>let</strong> 的绑定设为提供的新的值，然后跳转回顶部，不需要堆栈空间。最重要
的是，我们可以在程序中其他无关的宏中使用 <strong>fact</strong> 这个变量名。</p>
<p>为了实现这个跳转， <strong>nlet-tail</strong> 使用了 lisp 的特殊结构 ——<strong>tagbody</strong> 和 <strong>go</strong> 的组
合。这两个结构提供了个跳转（goto）系统。尽管结构化编程带来的问题（不管这意味着什么）
讨论广泛，COMMON LISP 提供这些特殊结构的原因正是我们在这里使用它们的原因。通过
控制程序计数器（执行中代码的当前位置），可以创建很有效的宏展开。虽然在现代高级语
言中，通常都不推荐用 <strong>goto</strong>，但快速浏览任意的汇编代码，就会发现 <strong>goto</strong> 在计算机软件
最底层上非常活跃。即使是最坚定的反 <strong>goto</strong> 倡导者也不建议抛弃像 C 这样的低级语言以及
<strong>goto</strong> 和 <strong>jump</strong> 汇编指令。在底层编程中，要想写出高效的代码，似乎只要 <strong>goto</strong>。</p>
<p>然而，正如 Alan Kay 所说， lisp 不是门语言，而是个构建原料。讨论 lisp 是否是高级还是
低级语言完全没有意义。有很高级的 lisp，如特定域（domain specific）语言。通过编写的
用于处理这些语言的宏，我们将它们的用法转换为较低层次的 lisp。当然，这些展开也是
lisp 代码，只是不像原始版本那样压缩。接下来，通常我们将这个中级的 lisp 代码交给编译器，
编译器会将这些代码转换为更低级别的 lisp 代码。用不多久，诸如 <strong>go-to</strong>、条件分支和位
填充等概念就会出现在代码中，但即便如此，代码还是 lisp。最后，使用本地代码编译器，
高级 lisp 程序将会转换成汇编语言。但即使是这时，代码依然还是 lisp。这是因为大部分 lisp
汇编程序都是用 lisp 本身编写的，所以很自然地这些汇编程序都保存为 lisp 对象，这样就产生
真正的 lisp 底层程序。只有程序真正变成二进制机器码时，它才不再是lisp。难道不是吗？</p>
<p>高阶或低阶的区别在 lisp 中不适用，lisp 程序的级别完全取决于视角。 Lisp 不是门语言，而是
迄今为止所发现的最灵活的软件构建原料。</p>
</section>
<section id="recursive-expansions">
<span id="id4"></span><h2>5.5 递归展开<a class="headerlink" href="#recursive-expansions" title="Permalink to this heading"></a></h2>
<p>在用例子教初学者 lisp 时，在课程中不可避免地会出现一个问题</p>
<blockquote>
<div><p>cadr 是什么玩意?</p>
</div></blockquote>
<p>这时有两种方法来回答这个问题。第一种方法就是向学生解释 lisp 的列表（list）是由 <strong>cons</strong>
单元组成，每个 <strong>cons</strong> 单元都有两个指针：<strong>car</strong> 和 <strong>cdr</strong>。一旦理解了这个概念，就很容易
展示如何将这些指针的访问器函数（也称为 <strong>car</strong> 和 <strong>cdr</strong>），这两个函数可以组合成 <strong>cadr</strong>
函数，而 <strong>cadr</strong> 函数会遍历列表然后获取列表中的第二个元素。</p>
<p>第二种方法就是给学生引入 <strong>second</strong> 这个 COMMON LISP 函数，然后完全忽略 <strong>cadr</strong>。而
<strong>cadr</strong> 和 <strong>second</strong> 效果是一样的：获取列表中的第二个元素。不同之处在于 <strong>second</strong> 是根
据它的结果来命名的，而 <strong>cadr</strong> 是根据它的过程来命名的。<strong>cadr</strong> 是显式的定义，而
<strong>second</strong> 是个容易记住的函数名，但它不合需要地模糊了操作的含义。 显式定义通常更好，
因为我们能想到的 <strong>cadr</strong> 函数不仅仅是获取列表的第二个元素。 例如，我们明显可以用
<strong>cadr</strong> 作为获取 <strong>lambda</strong> 结构参数解构列表的概念。 <strong>cadr</strong> 和 <strong>second</strong> 在底层执行
上是一样的，但在概念上可以表示不同的操作。</p>
<blockquote>
<div><p><strong>second</strong> 和 <strong>cadr</strong> 是完全一样的，都只能应用到列表上，不能应用到其他的序列类型上，
如向量、字符串之类的，即这两个函数的参数类型只能是列表。</p>
</div></blockquote>
<p>对显示定义来说，比哲学偏好更重要的是，<strong>car</strong> 和 <strong>cdr</strong> 的组合可以表示更多的列表访问操作，
而且比英文词组的访问器更一致。<strong>car</strong> 和 <strong>cdr</strong> 用处很大，因为可以把他们组合成新的、任意
的函数。例如，<strong>(cadadr x)</strong> 和 <strong>(car (cdr (car (cdr x))))</strong> 是一样的。COMMON
LISP 要求必须定义长度不大于 4 的 <strong>car</strong> 和 <strong>cdr</strong> 的所有组合。 因此，尽管没有函数
<strong>second-of-second</strong> 用于获取列表的第二个元素，然后将其作为列表并获取其第二个元素，
但可以使用 <strong>cadadr</strong> 达到这个效果。</p>
<p>这些预定义的 <strong>car</strong> 和 <strong>cdr</strong> 的组合用在函数的 <strong>:key</strong> 访问参数上真的很方便，像
<strong>find</strong> ：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>* (find &#39;a
    &#39;(((a b) (c d)) ((c d) (b a)))
    :key #&#39;cadadr)

((C D) (B A))
</pre></div>
</div>
<p>使用预定义的 <strong>cadadr</strong> 访问器比构建个等价的英文访问器组合的 lambda 表达式要更精确。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>* (find &#39;a
    &#39;(((a b) (c d)) ((c d) (b a)))
    :key (lambda (e)
          (second (second e))))

((C D) (B A))
</pre></div>
</div>
<p>COMMON LISP 也提供了函数 <strong>nth</strong> 和 <strong>nthcdr</strong>，他们可以用作通用访问器，比如说，
在不能确切地知道编译时想要获取哪个元素。<strong>nth</strong> 的定义很简单：从列表中取出 n 个 <strong>cdrs</strong>，
然后取一个 car。 所以 <strong>(nth 2 list)</strong> 与 <strong>(caddr list)</strong>、<strong>(third list)</strong> 是一样
的。<strong>nthcdr</strong> 也一样，只是它不做最后的 car：<strong>(nthcdr 2 list)</strong> 和 <strong>(cddr list)</strong> 是一样的。</p>
<p>但是，如果 <strong>cons</strong> 结构中的位置不能通过上述模式之一（如 <strong>nth</strong> 或 <strong>nthcdr</strong>）访问，就需
要组合访问器。不得不组合不一致的抽象来完成任务通常表明不完整。 能否为访问列表的域定义
一种域特定语言，以便将这些 <strong>car</strong> 和 <strong>cdr</strong> 组合函数、英语访问器以及像 <strong>nth</strong> 和
<strong>nthcdr</strong> 这样的函数结合起来？</p>
<p>既然 <strong>car</strong> 和 <strong>cdr</strong> 是基础操作符，我们的语言应该有完全通用的方式组合这两个访问器。因为
有无数种这样的组合，为每个可能的访问器定义函数来继续组合显然是不可行的。 我们真正想要
的是一个可以扩展为高效列表遍历代码的宏。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(defmacro cxr% (x tree)
  (if (null x)
    tree
    `(,(cond
          ((eq &#39;a (cadr x)) &#39;car)
          ((eq &#39;d (cadr x)) &#39;cdr)
          (t (error &quot;Non A/D symbol&quot;)))
      ,(if (= 1 (car x))
        `(cxr% ,(cddr x) ,tree)
        `(cxr% ,(cons (- (car x) 1) (cdr x))
                ,tree)))))
</pre></div>
</div>
<p>以 C 开头，后面跟着一个或多个 A 或 D 字符，以 R 结尾，指定列表访问器函数的语法非常直观，
这大致就是我们想要为我们的语言复制的内容。宏 <strong>cxr%</strong> 是这些访问器的双关语，其中一个或多个
A 或 D 字符被替换为 X。 在 <strong>cxr%</strong> 中，第一个参数是个列表，列表中指定这些了 A 和 D。这个
列表是数字和符号 A 或 D 的交替组合。</p>
<p>例如，即使 COMMON LISP 没有提供个英文单词的函数来访问列表的第十一个元素，我们也可以
简单地定义出来：</p>
<div class="highlight-lisp notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">eleventh</span><span class="w"> </span><span class="p">(</span><span class="nv">x</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="nv">cxr%</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="nv">d</span><span class="p">)</span><span class="w"> </span><span class="nv">x</span><span class="p">))</span><span class="w"></span>
</pre></div>
</div>
<p>本节的重点是说明递归展开的实际用途。当宏将一个结构展开为一个新的结构时，递归展开就会出现，
该结构也包含所讨论的宏的使用。 与所有递归一样，此过程必须有个基本的终止条件。宏最终会展开
为不包含使用相关宏的结构，然后这个展开就会结束。</p>
<p>下面我们将 <strong>cxr%</strong> 宏的实例宏展开（<strong>macroexpand</strong>）成一个同样使用 <strong>cxr%</strong> 的结构：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>* (macroexpand
    &#39;(cxr% (1 a 2 d) some-list))

(CAR (CXR% (2 D) SOME-LIST))
T
</pre></div>
</div>
<p>当我们拷贝这个新的递归结构，然后宏展开它，又会得到一个递归：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>* (macroexpand
    &#39;(CXR% (2 D) SOME-LIST))

(CDR (CXR% (1 D) SOME-LIST))
T
</pre></div>
</div>
<p>下面这个递归的结果展示了 <strong>xcr%</strong> 另一种可能的用法：空列表访问器：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>* (macroexpnad
    &#39;(CXR% (1 D) SOME-LIST))

(CDR (CXR% NIL SOME-LIST))
T
</pre></div>
</div>
<p>空列表访问器就是基本终止条件，然后直接展开被访问的列表：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>* (macroexpand
    &#39;(CXR% NIL SOME-LIST))

SOME-LIST
T
</pre></div>
</div>
<p>用 CMUCL 的拓展 <strong>macroexpand-all</strong> （一个完成的代码遍历器组件），可以看到
<strong>cxr%</strong> 结构的完整展开：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>* (walker:macroexpand-all
    &#39;(cxr% (1 a 2 d) some-list))
(CAR (CDR (CDR SOME-LIST)))
</pre></div>
</div>
<p>多亏了我们出色的 lisp 编译器，就意图和目的而言，<strong>cxr%</strong> 的使用和 <strong>caddr</strong> 与 <strong>third</strong> 一样。</p>
<p>但是，根据命名来看，<strong>cxr%</strong> 还不完善。这只是最终版 <strong>cxr</strong> 的初版。这个版本的第一个问题
就是 A 和 D 的数量只能是整型。因为这个限制，有些 <strong>nth</strong> 和 <strong>nthcdr</strong> 能做的事情我们的宏
却做不到。</p>
<p>我们需要检查将非整数作为 A 或 D 符号的数字前缀的情况。 在这种情况下，我们的代码展开应该
计算所提供的内容，并将此值用作要遍历的 <strong>cars</strong> 或 <strong>cdrs</strong> 的数量。</p>
<p><strong>cxr%</strong> 的第二个问题是，当 A 和 D 的前面的数字特别大时，<strong>cxr%</strong> 会内联所有的 <strong>car</strong>
和 <strong>cdr</strong> 的组合。对小的数字来说，内联可以提高性能，但通常内联过多的 <strong>car</strong> 和 <strong>cdr</strong>
没有意义； 相反，应该用像 <strong>nth</strong> 或 <strong>nthcdr</strong> 这样的循环函数。</p>
<p>为了解决这两个问题，我们添加了个替代展开。如果 A 或 D 前面的参数不是整型的话，就会调用
新的操作，而且，如果我们不想内联大量的 <strong>car</strong> 或 <strong>cdr</strong>，也可以选择调用新的操作。任选内联
阈值为 10，这个新的操作由 <strong>cxr</strong> 宏提供。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(defvar cxr-inline-thresh 10)

(defmacro! cxr (x tree)
  (if (null x)
    tree
    (let ((op (cond
                ((eq &#39;a (cadr x)) &#39;car)
                ((eq &#39;d (cadr x)) &#39;cdr)
                (t (error &quot;Non A/D symbol&quot;)))))
      (if (and (integerp (car x))
              (&lt;= 1 (car x) cxr-inline-thresh))
        (if (= 1 (car x))
          `(,op (cxr ,(cddr x) ,tree))
          `(,op (cxr ,(cons (- (car x) 1) (cdr x))
                    ,tree)))
        `(nlet-tail
          ,g!name ((,g!count ,(car x))
                  (,g!val (cxr ,(cddr x) ,tree)))
          (if (&gt;= 0 ,g!count)
            ,g!val
            ;; Will be a tail:
            (,g!name (- ,g!count 1)
                    (,op ,g!val))))))))
</pre></div>
</div>
<p>使用 <strong>cxr</strong>，我们可以直接根据 <strong>car</strong> 和 <strong>cdr</strong> 的显示指定来设计 <strong>nthcdr</strong>：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(defun nthcdr% (n list)
  (cxr (n d) list))
</pre></div>
</div>
<p>同样的，<strong>nth</strong>：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(defun nth% (n list)
  (cxr (1 a n d) list))
</pre></div>
</div>
<p>因为编写宏是个迭代的、分层次的过程，我们经常驱使自己使用组合或结合之前实现的宏。
例如，在 <strong>cxr</strong> 的定义中，替代展开用到了上一节中定义的宏：<strong>nlet-tail</strong>。
<strong>nlet-tail</strong> 很方便，因为它可以给迭代构造命名，同时，因为我们只计划将迭代作为
尾调用，就能保证使用它而避免不必要的堆栈消耗。</p>
<p>下面是 <strong>xcr</strong> 在 <strong>nthcdr%</strong> 中的展开：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>* (macroexpand
  &#39;(cxr (n d) list))
(LET ()
  (NLET-TAIL #:NAME1632
            ((#:COUNT1633 N)
              (#:VAL1634 (CXR NIL LIST)))
    (IF (&gt;= 0 #:COUNT1633)
      #:VAL1634
      (#:NAME1632 (- #:COUNT1633 1)
T
</pre></div>
</div>
<p>注意，复杂的宏展开的代码通常是程序员从不会去写的。特别要注意 <strong>nil cxrs</strong> 的使用
和无意义 <strong>let</strong> 的使用，这两者都留给了进一步的宏展开和编译器来优化。</p>
<p>因为宏可以让用户看到更多的展开，所以显示定义在其他语言中是不可能实现的。例如，
根据 <strong>cxr</strong> 的设计，当 A 和 D 前面的整数小于 <strong>cxr-inline-thresh</strong> 的参数时，
<strong>car</strong> 和 <strong>cdr</strong> 的调用会被内联：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>* (macroexpand &#39;(cxr (9 d) list))
(LET ()
  (CDR (CXR (8 D) LIST)))
T
</pre></div>
</div>
<p>但多亏了 <strong>cxr</strong> 的显示定义，我们可以传递一个值，尽管它本身不是整数，但在计算时将
成为整数。当我们这么做时，我们知道不会有内联，因为这个宏会变成 <strong>nlet-tail</strong> 展开。
计算一个整数最简单的结构就是将那个整数引起来：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>* (macroexpand &#39;(cxr (&#39;9 d) list))
(LET ()
  (NLET-TAIL #:NAME1638
            ((#:COUNT1639 &#39;9)
              (#:VAL1640 (CXR NIL LIST)))
    (IF (&gt;= 0 #:COUNT1639)
      #:VAL1640
      (#:NAME1638 (- #:COUNT1639 1)
T
</pre></div>
</div>
<p>通常我们会发现将宏组合起来很有用：<strong>cxr</strong> 可以展开成之前写的宏 <strong>nlet-tail</strong>。同样的，
有时将宏自身组合起来也很有用，这样就会有递归展开。</p>
</section>
<section id="recursive-solutions">
<span id="id5"></span><h2>5.6 递归方案<a class="headerlink" href="#recursive-solutions" title="Permalink to this heading"></a></h2>
<p>上节我们定义的 <strong>cxr</strong> 宏似乎包含了函数 <strong>car</strong> 和 <strong>cdr</strong> 的组合，以及普通的一元列表
<strong>(flat list)</strong> 访问器函数 <strong>nth</strong> 和 <strong>nthcdr</strong>。但是像 <strong>first</strong>, <strong>second</strong> 和 <strong>tenth</strong>
这样的英语访问器呢？</p>
<p>这些函数没有用吗？绝对不是。当表示访问列表中第四个元素的操作时，不论是在写代码
或是读代码的效率上，用 <strong>fourth</strong> 肯定要比数 <strong>cadddr</strong> 中三个 D 要更好。</p>
<p>事实上，英文单词访问器最大的问题是：COMMON LISP 中只有 10 个访问器 —— 从
<strong>first</strong> 到 <strong>tenth</strong>。但是本节或者说本书的主题之一是，lisp onion 的每一层都可以使用
其他层。lisp 中没有原语。如果我们想定义更多的单词访问器，如 <strong>eleventh</strong>，很容易
就能做到，就像之前展示的那样。用 <strong>defun</strong> 定义的 <strong>eleventh</strong> 函数与 ANSI 中定义的
<strong>first</strong> 和 <strong>tenth</strong> 访问器没有差别。因为没有原语，我们可以在宏定义中使用所有的
lisp，所以我们可以在宏定义中使用像 <strong>loop</strong> 和 <strong>format</strong> 这样的高级特性。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(defmacro def-english-list-accessors (start end)
  (if (not (&lt;= 1 start end))
    (error &quot;Bad start/end range&quot;))
  `(progn
    ,@(loop for i from start to end collect
        `(defun
          ,(symb
            (map &#39;string
                (lambda (c)
                    (if (alpha -char -p c)
                      (char-upcase c)
                      #\ -))
                (format nil &quot;~:r&quot; i)))
          (arg)
          (cxr (1 a ,(- i 1) d) arg)))))
</pre></div>
</div>
<p>宏 <strong>def-english-list-accessors</strong> 使用格式字符串 <strong>“~:r”</strong> 将数字 <strong>i</strong> 转换为
对应英文单词的字符串。按照 lisp 的习惯，我们将所有非字母字符改为连字符。然后
将这个字符串转换为一个符号，然后在 <strong>defun</strong> 结构中使用它，这个字符串运用 <strong>cxr</strong>
宏实现了适当的访问器功能。</p>
<p>例如，假设我们突然想到要访问列表的第十一个元素。当然，我们可以用 <strong>nth</strong> 或是
<strong>cdr</strong> 的组合以及英文单词访问器，但这会导致代码风格的不一致。我们可以重写
代码来避免使用英语访问器，但是选择用这种抽象可能是有原因的。</p>
<p>终于，我们可以自定义缺少的必要的访问器了。在其他语言中，这通常意味着大量的
复制粘贴，或者可能是一些特殊情况下的代码生成脚本，而这两者都不是特别优雅。
但在 lisp 中，我们有宏：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>* (macroexpand
  &#39;(def-english-list-accessors 11 20))
(PROGN
  (DEFUN ELEVENTH (ARG) (CXR (1 A 10 D) ARG))
  (DEFUN TWELFTH (ARG) (CXR (1 A 11 D) ARG))
  (DEFUN THIRTEENTH (ARG) (CXR (1 A 12 D) ARG))
  (DEFUN FOURTEENTH (ARG) (CXR (1 A 13 D) ARG))
  (DEFUN FIFTEENTH (ARG) (CXR (1 A 14 D) ARG))
  (DEFUN SIXTEENTH (ARG) (CXR (1 A 15 D) ARG))
  (DEFUN SEVENTEENTH (ARG) (CXR (1 A 16 D) ARG))
  (DEFUN EIGHTEENTH (ARG) (CXR (1 A 17 D) ARG))
  (DEFUN NINETEENTH (ARG) (CXR (1 A 18 D) ARG))
  (DEFUN TWENTIETH (ARG) (CXR (1 A 19 D) ARG)))
T
</pre></div>
</div>
<p>能够创建这些英语访问器降低了 ANSI COMMON LISP 中只有十个访问器限制的影响。
如果想要更多的英语访问器，只需使用 <strong>def- english-list-accessors</strong> 宏来
创建它们。</p>
<p>那 ANSI 里面关于 <strong>car</strong> 和 <strong>cdr</strong> 的组合最多只能是 5 个的限制怎么处理呢？有时，
在编写处理复杂列表的程序时，我们就不想访问器有这个限制。例如，当使用函数
<strong>cadadr</strong>、<strong>second-of-second</strong> 来访问列表，然后改变数据形式，改变后的数据
的引用是 <strong>second-of-third</strong> 或 <strong>cadaddr</strong>，这时就遇到了 COMMON LISP 的
限制。</p>
<p>和英文单词访问器的操作一样，我们可以写个程序来定义额外的 <strong>car</strong> 和 <strong>cdr</strong> 组合。
问题在于，与英文访问器不同，像 <strong>caddr</strong> 这样的组合函数，其深度的增加会导致
需要定义的函数数量呈指数级增加。具体来说，可以使用函数 <strong>cxr-calculator</strong>
找到需要定义的深度为 n 访问器数量。</p>
<div class="highlight-lisp notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">cxr-calculator</span><span class="w"> </span><span class="p">(</span><span class="nv">n</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="nv">for</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nv">from</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="nv">to</span><span class="w"> </span><span class="nv">n</span><span class="w"></span>
<span class="w">        </span><span class="nv">sum</span><span class="w"> </span><span class="p">(</span><span class="nb">expt</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="nv">i</span><span class="p">)))</span><span class="w"></span>
</pre></div>
</div>
<p>这里我们可以看到深度为 4 的组合需要有 30 种：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>* (cxr-calculator 4)

30
</pre></div>
</div>
<p>为了让你了解所需函数的数量增长有多快，参考下面这段代码：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>* (loop for i from 1 to 16
        collect (cxr-calculator i))

(2 6 14 30 62 126 254 510 1022 2046
4094 8190 16382 32766 65534 131070)
</pre></div>
</div>
<p>显然，要想 <strong>cxr</strong> 函数在深度上包含 <strong>car</strong> 和 <strong>cdr</strong> 的所有组合，我们需要一种
不同于处理英文访问器问题的方法。定义 <strong>car</strong> 和 <strong>cdr</strong> 的所有组合到某个可行
的深度是不行的。</p>
<div class="highlight-lisp notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">cxr-symbol-p</span><span class="w"> </span><span class="p">(</span><span class="nv">s</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">symbolp</span><span class="w"> </span><span class="nv">s</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nv">chars</span><span class="w"> </span><span class="p">(</span><span class="nb">coerce</span><span class="w"></span>
<span class="w">                    </span><span class="p">(</span><span class="nc">symbol</span><span class="w"> </span><span class="nv">-name</span><span class="w"> </span><span class="nv">s</span><span class="p">)</span><span class="w"></span>
<span class="w">                    </span><span class="ss">&#39;list</span><span class="p">)))</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="nb">and</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="p">(</span><span class="nb">length</span><span class="w"> </span><span class="nv">chars</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="nb">char=</span><span class="w"> </span><span class="sc">#\C</span><span class="w"> </span><span class="p">(</span><span class="nb">car</span><span class="w"> </span><span class="nv">chars</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="nb">char=</span><span class="w"> </span><span class="sc">#\R</span><span class="w"> </span><span class="p">(</span><span class="nb">car</span><span class="w"> </span><span class="p">(</span><span class="nb">last</span><span class="w"> </span><span class="nv">chars</span><span class="p">)))</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="nb">null</span><span class="w"> </span><span class="p">(</span><span class="nb">remove</span><span class="w"> </span><span class="nv">-if</span><span class="w"></span>
<span class="w">                </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="nv">c</span><span class="p">)</span><span class="w"></span>
<span class="w">                  </span><span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="p">(</span><span class="nb">char=</span><span class="w"> </span><span class="nv">c</span><span class="w"> </span><span class="sc">#\A</span><span class="p">)</span><span class="w"></span>
<span class="w">                      </span><span class="p">(</span><span class="nb">char=</span><span class="w"> </span><span class="nv">c</span><span class="w"> </span><span class="sc">#\D</span><span class="p">)))</span><span class="w"></span>
<span class="w">                </span><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="p">(</span><span class="nb">butlast</span><span class="w"> </span><span class="nv">chars</span><span class="p">))))))))</span><span class="w"></span>
</pre></div>
</div>
<p>首先，我们应该对 <strong>cxr</strong> 符号定义有个明确的说明。<strong>cxr-symbol-p</strong> 是个简洁
的定义：<strong>cxr</strong> 是所有以 C 开头，R 结尾，中间包含五个及以上个 A 或 D 的符号。
我们不考虑少于五个 A 或 D 的 <strong>cxr</strong> 符号，因为这些函数已经确定在 COMMON
LISP 中定义了。</p>
<p>接下来，因为我们打算用 <strong>cxr</strong> 来实现任意 <strong>car</strong> 和 <strong>cdr</strong> 组合的功能，所以创建了
函数 <strong>cxr-symbol-to-cxr-list</strong></p>
<div class="highlight-lisp notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">cxr-symbol-to-cxr-list</span><span class="w"> </span><span class="p">(</span><span class="nv">s</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="k">labels</span><span class="w"> </span><span class="p">((</span><span class="nv">collect</span><span class="w"> </span><span class="p">(</span><span class="nv">l</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="nv">l</span><span class="w"> </span><span class="p">(</span><span class="nb">list*</span><span class="w"></span>
<span class="w">                    </span><span class="mi">1</span><span class="w"></span>
<span class="w">                    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">char=</span><span class="w"> </span><span class="p">(</span><span class="nb">car</span><span class="w"> </span><span class="nv">l</span><span class="p">)</span><span class="w"> </span><span class="sc">#\A</span><span class="p">)</span><span class="w"></span>
<span class="w">                      </span><span class="ss">&#39;A</span><span class="w"></span>
<span class="w">                      </span><span class="ss">&#39;D</span><span class="p">)</span><span class="w"></span>
<span class="w">                    </span><span class="p">(</span><span class="nv">collect</span><span class="w"> </span><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="nv">l</span><span class="p">))))))</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="nv">collect</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="nb">cdr</span><span class="w">       </span><span class="c1">; chop off C</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="nb">butlast</span><span class="w"> </span><span class="c1">; chop off R</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="nb">coerce</span><span class="w"></span>
<span class="w">            </span><span class="p">(</span><span class="nc">symbol</span><span class="w"> </span><span class="nv">-name</span><span class="w"> </span><span class="nv">s</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="ss">&#39;list</span><span class="p">))))))</span><span class="w"></span>
</pre></div>
</div>
<p><strong>cxr-symbol-to-cxr-list</strong> 函数用来将 <strong>cxr</strong> 符号（由 <strong>cxr-symbol-p</strong> 定义）
转换为一个可以用作 <strong>cxr</strong> 第一个参数的列表。下面是它的用法：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>* (cxr-symbol-to-cxr-list
    &#39;caddadr)
(1 A 1 D 1 D 1 A 1 D)
</pre></div>
</div>
<p>注意 <strong>cxr-symbol-to-cxr-list</strong> 中 <strong>list*</strong> 函数的用法。<strong>list*</strong> 基本和 <strong>list</strong>
一致，除了它的最后一个参数会插入到已创建列表中最后一个 <strong>cons</strong> 单元格的 <strong>cdr</strong>
位置。当编写递归函数构建一个列表（其中每个堆栈结构可能想向列表中添加多个元素）
时， <strong>list*</strong> 就非常方便，。在我们的例子中，每个结构都想向列表中添加两个元素：
数字 1 和符号 A 或 D。</p>
<p>最后，我们认为有效地提供任意深度的 <strong>cxr</strong> 函数的唯一方法是，对提供的表达式进行
代码遍历并只定义必要的函数。<strong>with-all-cxrs</strong> 宏使用 Graham 的 <strong>flatten</strong> 实用
程序对所提供的表达式进行代码遍历，方法与 [3.5 异常捕获]中的 <strong>defmacro/g!</strong> 宏一样。
<strong>with -all-cxrs</strong> 找到所有满足 <strong>cxr-symbol-p</strong> 的符号，用 <strong>cxr</strong> 宏创建它们引用的函
数，然后用标签形式将这些函数绑定到提供的代码周围。</p>
<div class="highlight-lisp notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defmacro</span><span class="w"> </span><span class="nv">with-all-cxrs</span><span class="w"> </span><span class="p">(</span><span class="k">&amp;rest</span><span class="w"> </span><span class="nv">forms</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="o">`</span><span class="p">(</span><span class="k">labels</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="o">,@</span><span class="p">(</span><span class="nb">mapcar</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="nv">s</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="o">`</span><span class="p">(</span><span class="o">,</span><span class="nv">s</span><span class="w"> </span><span class="p">(</span><span class="nv">l</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">(</span><span class="nv">cxr</span><span class="w"> </span><span class="o">,</span><span class="p">(</span><span class="nv">cxr-symbol-to-cxr-list</span><span class="w"> </span><span class="nv">s</span><span class="p">)</span><span class="w"></span>
<span class="w">                  </span><span class="nv">l</span><span class="p">)))</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="nb">remove</span><span class="w"> </span><span class="nv">-duplicates</span><span class="w"></span>
<span class="w">          </span><span class="p">(</span><span class="nb">remove-if-not</span><span class="w"></span>
<span class="w">            </span><span class="nf">#&#39;</span><span class="nv">cxr-symbol-p</span><span class="w"></span>
<span class="w">      </span><span class="o">,@</span><span class="nv">forms</span><span class="p">))</span><span class="w"></span>
</pre></div>
</div>
<p>现在可以在传给 <strong>with-all-cxrs</strong> 的结构中封装表达式，并假定这些表达式可以访问任何
可能的 <strong>cxr</strong> 函数。如果我们想的话，我们可以很简单的返回这些函数然后用在别处：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>* (with-all-cxrs #&#39;cadadadadadr)

#&lt;Interpreted Function&gt;
</pre></div>
</div>
<p>或者，如下面的宏展开所示，我们可以用这个无限类嵌入任意复杂的 lisp 代码:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>* (macroexpand
  &#39;(with-all-cxrs
      (cons
        (cadadadr list)
        (caaaaaaaar list))))
(LABELS
  ((CADADADR (L)
    (CXR (1 A 1 D 1 A 1 D 1 A 1 D) L))
  (CAAAAAAAAR (L)
    (CXR (1 A 1 A 1 A 1 A 1 A 1 A 1 A 1 A) L)))
  (CONS
    (CADADADR LIST)
    (CAAAAAAAAR LIST)))
T
</pre></div>
</div>
<p>通常，一个听起来很难的任务，如定义无限个英文列表访问器和 <strong>car-cdr</strong> 组合，
其实就是将简单的问题聚合到一起。与之相反，对单个难题，可以通过递归处理问题
来解决一系列较简单的问题。通过思考如何将一个问题转化为一系列更简单的问题，
我们采用了经过验证的解决方法：分而治之。</p>
</section>
<section id="dlambda">
<span id="id6"></span><h2>5.7 Dlambda<a class="headerlink" href="#dlambda" title="Permalink to this heading"></a></h2>
<p>在讨论闭包时，我们提到了怎么将闭包当作对象使用，以及一般情况下，不确定范围和词法
作用域怎么替代复杂的对象系统。但是，到目前为止，我们忽略了对象通常都有的一个特性：
多方法。换句话说，虽然我们简单的计数器闭包示例只允许一个操作，即增量，但对象通常
都能能够用不同的行为响应不同的消息。</p>
<p>尽管闭包可以被认为是个只有一个方法（ <strong>apply</strong> ）的对象，但可以根据传递给它的参数
来设计个方法，使其具有不同的行为。例如，如果我们将第一个参数指定为表示所传递消息
的符号，则可以基于第一个参数用简单的 <strong>case</strong> 语句提供多个行为。</p>
<p>为实现一个具有增加和减少方法的计数器，可能会这样写：</p>
<div class="highlight-lisp notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nb">count</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="nv">msg</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="nb">case</span><span class="w"> </span><span class="nv">msg</span><span class="w"></span>
<span class="w">      </span><span class="p">((</span><span class="ss">:inc</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="nb">incf</span><span class="w"> </span><span class="nb">count</span><span class="p">))</span><span class="w"></span>
<span class="w">      </span><span class="p">((</span><span class="ss">:dec</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="nb">decf</span><span class="w"> </span><span class="nb">count</span><span class="p">)))))</span><span class="w"></span>
</pre></div>
</div>
<p>注意，上述例子中使用了关键字符号，也就是冒号 <strong>:</strong> 开头的符号，通常计算这些符号用来
指代消息。关键字很方便，因为不需要引用它们或从包中导出它们，而且很直观，因为它们
就是设计来执行这个和其他类型的解构。通常在 <strong>lambda</strong> 或 <strong>defmacro</strong> 结构中，关键字
在运行时不会被解构。但是由于我们正在实现一个消息传递系统，这个系统会在运行时解构，
所以我们将关键字处理操作留在运行时执行。如前所述，符号的解构是个高效的操作（仅仅
是指针比较）。计数器例子在编译时，可能会被缩减为以下机器码：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>2FC:       MOV  EAX, [#x582701E4]  ; :INC
302:       CMP  [EBP-12], EAX
305:       JEQ  L3
307:       MOV  EAX, [#x582701E8]  ; :DEC
30D:       CMP  [EBP-12], EAX
310:       JEQ  L2
</pre></div>
</div>
<p>但为了方便起见，我们要避免每创建个对象或类时都要编写一个对应的条件语句。这里就要
用到宏了。我喜欢用的宏是 <strong>dlambda</strong>，他会展开成 lambda 结构。这个展开包括一种方法，
这个方法可以根据应用的参数执行许多不同的代码分支。这种运行时解构的类型就是
<strong>dlambda</strong> 名称的来源：它是 <strong>lambda</strong> 的解构或调度版本。</p>
<div class="highlight-lisp notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nv">defmacro!</span><span class="w"> </span><span class="nv">dlambda</span><span class="w"> </span><span class="p">(</span><span class="k">&amp;rest</span><span class="w"> </span><span class="nv">ds</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="o">`</span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="k">&amp;rest</span><span class="w"> </span><span class="o">,</span><span class="nv">g!args</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="nb">case</span><span class="w"> </span><span class="p">(</span><span class="nb">car</span><span class="w"> </span><span class="o">,</span><span class="nv">g!args</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="o">,@</span><span class="p">(</span><span class="nb">mapcar</span><span class="w"></span>
<span class="w">          </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="nv">d</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="o">`</span><span class="p">(</span><span class="o">,</span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">eq</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="p">(</span><span class="nb">car</span><span class="w"> </span><span class="nv">d</span><span class="p">))</span><span class="w"></span>
<span class="w">                </span><span class="no">t</span><span class="w"></span>
<span class="w">                </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="p">(</span><span class="nb">car</span><span class="w"> </span><span class="nv">d</span><span class="p">)))</span><span class="w"></span>
<span class="w">            </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="o">,@</span><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="nv">d</span><span class="p">))</span><span class="w"></span>
<span class="w">                  </span><span class="o">,</span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">eq</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="p">(</span><span class="nb">car</span><span class="w"> </span><span class="nv">d</span><span class="p">))</span><span class="w"></span>
<span class="w">                      </span><span class="nv">g!args</span><span class="w"></span>
<span class="w">                      </span><span class="o">`</span><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="o">,</span><span class="nv">g!args</span><span class="p">)))))</span><span class="w"></span>
<span class="w">        </span><span class="nv">ds</span><span class="p">))))</span><span class="w"></span>
</pre></div>
</div>
<p><strong>dlambda</strong> 的第一个参数是个关键词符号。根据使用的关键字符号，<strong>dlambda</strong> 将执行相应
的代码段。例如，我们最喜欢的闭包例子：简单的计数器，可以使用 <strong>dlambda</strong>，根据第一个
参数增加或减少计数。这就是所谓的 <strong>let over dlambda</strong> 模式：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>* (setf (symbol-function &#39;count-test)
    (let ((count 0))
      (dlambda
        (:inc () (incf count))
        (:dec () (decf count)))))

#&lt;Interpreted Function&gt;
</pre></div>
</div>
<p>既可以递增</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>* (count-test :inc)

1
</pre></div>
</div>
<p>也可以递减</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>* (count-test :dec)

0
</pre></div>
</div>
<p>闭包取决于传递的第一个参数。尽管在上面的 let over dlambda 中为空，关键字符号后面
的列表实际上是 lambda 析构列表。每个调度，或者说每个关键字参数，都可以有自己特定
的 lambda 解构列表，就像下面对计数器闭包的增强:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>* (setf (symbol-function &#39;count-test)
    (let ((count 0))
      (dlambda
        (:reset () (setf count 0))
        (:inc (n) (incf count n))
        (:dec (n) (decf count n))
        (:bound (lo hi)
          (setf count
            (min hi
                (max lo
                      count)))))))

#&lt;Interpreted Function&gt;
</pre></div>
</div>
<p>现在，我们有几个不同的 lambda 解构列表可以使用，具体取决于第一个关键词参数，
<strong>:reset</strong> 不需要参数，然后会将 <strong>count</strong> 置为 0：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>* (count-test :reset)

0
</pre></div>
</div>
<p><strong>:inc</strong> 和 <strong>:dec</strong> 都接受数字参数，<strong>n</strong>：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>* (count-test :inc 100)

100
</pre></div>
</div>
<p><strong>:bound</strong> 确保 <strong>count</strong> 的值时在边界值 <strong>lo</strong> 和 <strong>hi</strong> 之中。若 <strong>count</strong> 的值落在
边界值之外，那么它会变成离该值较近的那个边界值：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>* (count-test :bound -10 10)

10
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>上面代码的结果之所以为 10 是因为上面的值已经将 <strong>count</strong> 设置为 100 了，加上了
<strong>:bond</strong> 后就变成 10 了</p>
</div>
<p><strong>dlambda</strong> 一个重要的属性是，它使用 lambda 进行所有的解构，因此保留了正常的
错误检查和 COMMON LISP 环境中的调试（debugging）。例如，当只给 <strong>count-test</strong>
一个参数时，就会直接得到个和 lambda 程序类似的报错：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>* (count-test :bond -10)

ERROR: Wrong argument count, wanted 2 and got 1.
</pre></div>
</div>
<p>特别是当 <strong>dlambda</strong> 嵌入到词法环境中形成个闭包，<strong>dlambda</strong> 可以让我们使用面向
对象的方式编程，就像是创建个多方法的对象。 <strong>dlambda</strong> 经过适配，在不偏离
lambda 语法和用法的情况下，使该功能易于访问。 <strong>dlambda</strong> 仍然会展开成单个
lambda 表达式，因此，它的求值结果与对 <strong>lambda</strong> 求值完全相同：一个可以保存、
应用的匿名函数，最重要的是，可以将这个 lambda 控件用作词法闭包。</p>
<p>但 <strong>dlambda</strong> 将这种同步与 <strong>lambda</strong> 更进一步。为了让 <strong>dlambda</strong> 尽可能平滑地
从包含 <strong>lambda</strong> 宏的代码转换，<strong>dlambda</strong> 可以不将关键字参数作为第一个符号
传递的匿名函数调用。当我们通过正常的 <strong>lambda</strong> 接口使用闭包编写了大量的代码时，
我们希望能够添加特殊情况的 <strong>dlambda</strong> 方法，而不改变其他代码调用接口的方式。</p>
<p>如果说最后可能的方法是给定符号 <strong>t</strong> 而不是关键字参数，在没有发现任何特殊情况的
关键字参数方法适用时，所提供的方法将始终被调用。以下是个特意编造的例子：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>* (setf (symbol-function &#39;dlambda-test)
    (dlambda
      (:something-special ()
        (format t &quot;SPECIAL~%&quot;))
      (t (&amp;rest args)
        (format t &quot;DEFAULT: ~a~%&quot; args))))

#&lt;Interpreted Function&gt;
</pre></div>
</div>
<p>有了这个定义，调用该函数的主要方法就是调用默认情况。默认情况用了 lambda 解构
参数的 <strong>&amp;rest</strong> 来接收所有可能的参数，我们可以通过提供更具体的 lambda 解构参数
自由地缩小可接受的参数。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>* (dlambda-test 1 2 3)
DEFAULT: (1 2 3)
NIL
* (dlambda-test)
DEFAULT: NIL
NIL
</pre></div>
</div>
<p>然而，尽管这个匿名函数的行为很像用默认情况定义的常规 lambda 结构，但我们可以
传递一个关键字参数来调用这个特殊方法。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>* (dlambda-test :something-special)
SPECIAL
NIL
</pre></div>
</div>
<p>一个关键特性(后面的章节将会大量利用)是，默认方法和所有特殊方法当然都是在包含
<strong>dlambda</strong> 的词法上下文中调用的。由于 <strong>dlambda</strong> 与 <strong>lambda</strong> 表示法集成得非常紧密，
这使得我们可以将多方法技术引入到创建和扩展词法闭包的领域。</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="chapter04.html" class="btn btn-neutral float-left" title="第四章：读取宏" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="chapter06.html" class="btn btn-neutral float-right" title="第六章：回指（Anaphoric）宏" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021-2022, Yuqi Liu, Xuting Yang, Chuangxiu Chen.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>